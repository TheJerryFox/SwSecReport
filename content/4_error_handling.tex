\chapter{Fehlerbehandlung}
Rust bietet einen robusten Ansatz zur Fehlerbehandlung, der ohne Ausnahmen (\glspl{exception}) auskommt und eine sichere und vorhersehbare Fehlerbehandlung ermöglicht. 
Im Gegensatz zu vielen anderen Programmiersprachen verwendet Rust das \texttt{Result} und \texttt{Option} Typsystem, um Fehler und fehlende Werte explizit zu behandeln.\\
\\
Fehler werden durch den \texttt{Result<T, E>}-Typen dargestellt. 
\texttt{Result<T, E>} ist ein Typ, der entweder einen Wert vom Typ \texttt{T} oder einen Fehler vom Typ \texttt{E} enthält. 

\begin{lstlisting}[language=Rust, caption=Sichere Fehlerbehandlung]
use std::fs::File;
use std::io::Read;

pub fn get_file() {
    match read_file_content() {
        Ok(contents) => println!("File contents: {}", contents),
        Err(e) => println!("Error reading file: {}", e),
    }
}

fn read_file_content() -> Result<String, std::io::Error> {
    let mut file = File::open("example.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
\end{lstlisting}
\noindent
Die Funktion \texttt{read\_file\_contet()} gibt einen \texttt{Result}-Type zurück, welcher einen Fehler beinhaltet, sollte die Dateioperation fehlschlagen.
Mittels \texttt{match} kann überprüft werden, ob das Result \texttt{OK} ist und ein Wert vorliegt oder ob das \texttt{Result} ein Fehler ist.\\
\\
Generell müssen in Rust alle möglichen Fehler behandelt werden.
Dies kann auch durch \texttt{unwrap()} geschechen, welches den \texttt{Some}-Wert zurück gibt oder im falle eines Fehlers eine \textit{\gls{panic}} wirft.
In beiden fällen muss der Programierer diese jedoch expliziet behandeln.

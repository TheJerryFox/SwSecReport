\chapter{Fehlerbehandlung}
Rust bietet einen robusten Ansatz zur Fehlerbehandlung, der ohne Ausnahmen (\glspl{exception}) auskommt und eine sichere und vorhersehbare Fehlerbehandlung ermöglicht. 
Im Gegensatz zu vielen anderen Programmiersprachen verwendet Rust das \texttt{Result} und \texttt{Option}-Typsystem, um Fehler und fehlende Werte explizit zu behandeln.\\
\\
Fehler werden durch den \texttt{Result<T, E>}-Typ dargestellt. \texttt{Result<T, E>} ist ein Typ, der entweder einen Wert vom Typ \texttt{T} oder einen Fehler vom Typ \texttt{E} enthält.

\begin{lstlisting}[language=Rust, caption=Sichere Fehlerbehandlung]
use std::fs::File;
use std::io::Read;

pub fn get_file() {
    match read_file_content() {
        Ok(contents) => println!("File contents: {}", contents),
        Err(e) => println!("Error reading file: {}", e),
    }
}

fn read_file_content() -> Result<String, std::io::Error> {
    let mut file = File::open("example.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
\end{lstlisting}
\noindent
Die Funktion \texttt{read\_file\_content()} gibt einen \texttt{Result}-Typ zurück, welcher einen Fehler beinhaltet, sollte die Dateioperation fehlschlagen. 
Mittels \texttt{match} kann überprüft werden, ob das Result \texttt{OK} ist und ein Wert vorliegt oder ob das \texttt{Result} ein Fehler ist.\\
\\
Generell müssen in Rust alle möglichen Fehler behandelt werden. 
Dies kann auch durch \texttt{unwrap()} geschehen, welches den \texttt{OK}-Wert zurückgibt oder im Falle eines Fehlers eine \textit{\gls{panic}} wirft. 
In beiden Fällen muss der Programmierer diese jedoch explizit behandeln.

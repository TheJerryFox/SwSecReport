
\chapter{Statische Typen}

Rust ist eine statisch typisierte Programmiersprache, was bedeutet, dass die Typen aller Variablen zur Kompilierzeit bekannt sein müssen. 
Dies ermöglicht dem Compiler, viele Fehler frühzeitig zu erkennen und zu verhindern. 
Unsichere Operationen wie Dereferenzierungen von Nullzeigern, ungesicherte Typumwandlungen, Typfehler und Typinkompatibilitäten werden so vermieden.
\begin{lstlisting}[language=Rust, caption={i32 in i64}, label=list:static_type]
pub fn i32_in_i64() {
    let smol: i32 = 128;

    // panic: i32 will not get converted to i64
    let big: i64 = smol;

    // explicit conversion from i32 to i64 
    let big: i64 = smol.into();

    println!("i32 in i64: {}", big);
}
\end{lstlisting}

\noindent
Beispiel \ref{list:static_type} zeigt den Versuch, einen \texttt{i32}-Wert direkt in einen \texttt{i64}-Wert zu konvertieren, was nicht erlaubt ist. 
Stattdessen kann die Methode \texttt{into()} verwendet werden, um explizit eine Typenkonvertierung vorzunehmen. 
Rust führt keine impliziten Konvertierungen durch; der Programmierer muss an dieser Stelle explizit sein \cite[Kapitel 1, Types]{drysdale2024}.

\begin{lstlisting}[language=Rust, caption={Signiertheit}, label=list:signdness]
pub fn signdness() {
    let unsigned_val: u32 = 150;
    let signed_val: i32 = -100;

    // will panic 
    let signed: i32 = unsigned_val;
    let unsigned: u32 = signed_val;

    // explicit conversion from unsigned to signed
    let signed_from_unsigned: i32 = unsigned_val as i32;
    println!("Signed from Unsigned: {}", signed_from_unsigned);

    // explicit conversion from signed to unsigned
    // has a logial error in this context and overflows
    let unsigned_from_signed: u32 = signed_val as u32;
    println!("Unsigned from Signed: {}", unsigned_from_signed); 
    }
\end{lstlisting}
\noindent
Das Beispiel \ref{list:signdness} zeigt die Funktion \texttt{signdness()}, die mögliche Probleme bei der Konvertierung zwischen signierten und unsignierten Typen darstellt. 
Direkte Konvertierungen können zu logischen Fehlern oder Überläufen führen. 
Daher ist es wichtig, explizite und sichere Methoden zu verwenden. 
er Programmierer muss hierbei explizit eine Konvertierung veranlassen.\\
\\
In vielen dynamisch typisierten Sprachen wie Python oder JavaScript werden Typfehler erst zur Laufzeit entdeckt, was zu unvorhersehbarem Verhalten und potenziellen Sicherheitslücken führen kann. 
Zudem werden ebenfalls in diesen Sprachen implizite Typen-Konvertierungen, vorgenommen. \cite[Kapitel 1: Types]{drysdale2024}.
Auch dies unterbindet rust wie in Beispiel \ref{list:static_type} und \ref{list:signdness} gezeigt.

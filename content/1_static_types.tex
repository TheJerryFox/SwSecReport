
\chapter{Statische Typen}

Rust ist eine statisch typisierte Programmiersprache, was bedeutet, dass die Typen aller Variablen zur Kompilierzeit bekannt sein müssen. 
Dies ermöglicht dem Compiler, viele Fehler frühzeitig zu erkennen und zu verhindern, dass unsichere Operationen wie Dereferenzierungen von Nullzeigern oder ungesicherte Typumwandlungen, Typfehler und Typinkompatibilitäten ausgeführt werden. 

\begin{lstlisting}[language=Rust, caption={i32 in i64}, label=list:static_type]
pub fn i32_in_i64() {
    let smol: i32 = 128;

    // panic: i32 will not get converted to i64
    let big: i64 = smol;

    // explicit conversion from i32 to i64 
    let big: i64 = smol.into();

    println!("i32 in i64: {}", big);
}
\end{lstlisting}

\noindent
Beispiel \ref{list:static_type} den Versuch, einen \texttt{i32}-Wert direkt in einen \texttt{i64}-Wert zu konvertieren, was nicht erlaubt ist. 
Stattdessen kann die Methode \texttt{into()} verwendet werden, um explizit eine Typenkonvertierung zu veranlassen. 
Rust führt keine impliziten Konvertierungen durch; der Programmierer muss an dieser Stelle explizit sein \cite[Kapitel 1. Types]{drysdale2024}.

\begin{lstlisting}[language=Rust, caption={Signiertheit}, label=list:signdness]
pub fn signdness() {
    let unsigned_val: u32 = 150;
    let signed_val: i32 = -100;

    // will panic 
    let signed: i32 = unsigned_val;
    let unsigned: u32 = signed_val;

    // explicit conversion from unsigned to signed
    let signed_from_unsigned: i32 = unsigned_val as i32;
    println!("Signed from Unsigned: {}", signed_from_unsigned);

    // explicit conversion from signed to unsigned
    // has a logial error in this context and overflows
    let unsigned_from_signed: u32 = signed_val as u32;
    println!("Unsigned from Signed: {}", unsigned_from_signed); 
    }
\end{lstlisting}
\noindent
Das Beispiel \ref{list:signdness} zeigt die Funktion \texttt{signdness()} die möglichen Probleme bei der Konvertierung zwischen signierten und unsignierten Typen. 
Direkte Konvertierungen können zu logischen Fehlern oder Überläufen führen, daher ist es wichtig, explizite und sichere Methoden zu verwenden.
Auch hier muss der Programierer explizit eine Konvertierung angeben.\\
\\
In vielen dynamisch typisierten Sprachen wie Python oder JavaScript werden Typfehler erst zur Laufzeit entdeckt, was zu unvorhersehbarem Verhalten und potenziellen Sicherheitslücken führen kann.
Des weiteren werden impliziete Konvertierungen vermieden, wie diese beispielsweiße in C\# aufeten wass unerwartet verhalten verursachen kann \cite[Kapitel 1. Types]{drysdale2024}.


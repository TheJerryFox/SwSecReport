\chapter{Zero-Cost-Abstraktionen}

Zero-Cost-Abstraktionen sind ein zentrales Konzept in Rust, das es ermöglicht, hohe Abstraktionen zu verwenden, ohne die Laufzeit des Programms zu beeinträchtigen.
Dies bedeutet, dass der Overhead, der durch die Abstraktionen entsteht, zur Kompilierzeit eliminiert wird, sodass der generierte Maschinencode ähnlich effizient ist wie handgeschriebener Low-Level-Code \cite{sequeira2023}.
In anderen Sprachen kann dies zu eimem Laufzeit-Overhead führen \cite{haberman2014}.

\section{Iteratoren}
Iteratoren helfen um über eine menge von elementen zu Iterieren und ersetzen eine expliziete schleife.
\begin{lstlisting}[language=Rust, caption=Iterator]
use std::sync::mpsc;
use std::thread;

pub fn iterator(){
    let numbers = vec![1, 2, 3, 4, 5];

    // Using an iterator to iterate through the vector safely
    for num in numbers.iter() {
        println!("{}", num); // Safely prints each number
    }
}
\end{lstlisting}
Ein solcher Iterator löst die Programmlogik von der Schleifenlogik, wodurch typische Fehler wie \textit{\gls{off-by-one}} und daraus resultierende z.B. falsche Array-Indexierung (Buffer-oferlow) vermieden werden.
\cleardoublepage
\section{Message Passing}

Message Passing ist eine sichere und effiziente Methode zur Kommunikation zwischen Threads, die in Rust ebenfalls ohne Laufzeitkosten implementiert ist:

\begin{lstlisting}[language=Rust, caption=Message Passing ]
pub fn message_passing(){
    let (tx, rx) = mpsc::channel();

    let sender_thread = thread::spawn(move || {
        let msg = "Hello from the sender thread";
        // Sends a message safely to the receiver
        tx.send(msg).unwrap(); 
        println!("Sent message: '{}'", msg);
    });

    let receiver_thread = thread::spawn(move || {
        // Receives message safely
        let received = rx.recv().unwrap(); 
        println!("Received message: '{}'", received);
    });

    sender_thread.join().unwrap();
    receiver_thread.join().unwrap();
}
\end{lstlisting}
Durch eine solche einfach Abstraktion können Datenrennen zwischen threads vermieden werden.
Trotzdem können Threads effektiv komunizieren und der Code bleibt lesbar.
\cleardoublepage
\section{Option Typ}

Der \texttt{Option} Typ wird verwendet, um mögliche Abwesenheit eines Wertes sicher zu handhaben. Hier ist ein Beispiel, wie man eine Division sicher durchführen kann:

\begin{lstlisting}[language=Rust, caption=Option Typ]
pub fn option_type(){
    let dividend = 10;
    let divisor = 0;

    match find_divisor(dividend, divisor) {
        Some(result) => println!("Result of division: {}", result),
        None => println!("Cannot divide by zero!"),
    }
}

fn find_divisor(dividend: i32, divisor: i32) -> Option<i32> {
    if divisor == 0 {
        None // Safely handle division by zero
    } else {
        Some(dividend / divisor) // Safely return the result
    }
}
\end{lstlisting}
\noindent
Eine \texttt{Option} gibt entweder einen wert \texttt{Some} zurück oder einen \texttt{None} Wert.
Mittels \texttt{match} kann geprüft werden ob ein Wert vorliegt und dementsprechend verarbeitet werden.

\section{Filter-Funktion}

Die \texttt{filter} Methode ermöglicht es, Elemente eines Iterators basierend auf einer Bedingung zu filtern.

\begin{lstlisting}[language=Rust, caption=Filter-Funktion]
pub fn filter(){
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // Use filter to find even numbers
    let even_numbers: Vec<_> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .collect();

    println!("Even numbers: {:?}", even_numbers);
}
\end{lstlisting}
Ein Filter auf einem Iterator seperiert zusätzlich die Filter logik.
An dieser stelle könnte auch eine Methode verwendet werden.
Dies sorgt für besser lesbaren Code und beugt logik fehlern vor (\textit{\gls{off-by-one}} etc.).

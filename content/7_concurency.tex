\chapter{Sichere Nebenläufigkeit}

Nebenläufigkeit ist ein wesentlicher Aspekt moderner Softwareentwicklung, insbesondere bei der Entwicklung von Systemen, die eine hohe Leistung und Reaktionsfähigkeit erfordern. 
Jedoch birgt die Nebenläufigkeit zahlreiche Herausforderungen, insbesondere im Hinblick auf die Sicherheit und Korrektheit des Codes. 
Datenrennen sind ein häufiges Problem, das auftritt, wenn mehrere Threads gleichzeitig auf dieselben Daten zugreifen und diese ändern, ohne dass die Zugriffe korrekt synchronisiert sind.\\ 
\\
Rust bietet einen Ansatz zur sicheren Nebenläufigkeit, indem es die Konzepte der Besitzrechte (Ownership) und des Ausleihens (Borrowing) auf Threads anwendet. 
Dies wird durch die Einbindung von Mechanismen wie \texttt{Arc} (Atomic Reference Counting) und \texttt{Mutex} (Mutual Exclusion) erreicht, die sicherstellen, dass Datenrennen verhindert werden.\\
\\
\texttt{Arc} (Atomic Reference Counting) ist ein Thread-sicherer Referenzzähler, der es ermöglicht, dass mehrere Threads gleichzeitig Besitz an den gleichen Daten haben, indem er die Daten im Heap speichert und den Zähler atomar verwaltet. \\
\\
\texttt{Mutex} (Mutual Exclusion) ist ein Synchronisationsprimitiv, das sicherstellt, dass nur ein Thread zu einem bestimmten Zeitpunkt auf die geschützten Daten zugreifen kann\\
\\
\texttt{Arc} übernimmt das Zählen der Referenzen, während \texttt{Mutex} den exklusiven Zugriff auf die Daten garantiert. Dies funktioniert reibungslos mit Rusts Ownership- und Borrowing-System, da \texttt{Arc} die Besitzrechte an den Daten teilt und \texttt{Mutex} den Zugriff kontrolliert, um Datenrennen zu vermeiden.
\cleardoublepage
\begin{lstlisting}[language=Rust, caption=Sicheres Erstellen von Threads ]
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use rand::{thread_rng, Rng}; 

pub fn create_increment_threads(){
    let counter = Arc::new(Mutex::new(0));
    let mut children = vec![];

    for _ in 0..5 {
        let counter_clone = Arc::clone(&counter);
        let child = thread::spawn(move || {
            let mut rng = thread_rng(); 
            // Loop to add to the counter 10 times
            for _ in 0..10 { 
                {
                    let mut num = match counter_clone.lock() {
                        Ok(x) => x,
                        Err(_) => todo!(),
                    };
                    *num += 1;
                } // MutexGuard goes out of scope here, 
                  //releasing the lock

                let sleep_time = rng.gen_range(1..=3); 
                // Sleep for random duration
                thread::sleep(Duration::from_millis(sleep_time)); 
            }
        });
        children.push(child);
    }

    // Wait for all threads to complete
    for child in children {
        child.join().unwrap();
    }

    // Print the result
    println!("Final counter value: {}", *counter.lock().unwrap());
}
\end{lstlisting}
\noindent
In diesem Beispiel wird ein gemeinsamer Zähler von mehreren Threads erhöht. 
Die Verwendung von \texttt{Arc<Mutex<i32>}, stellt sicher, dass nur ein Thread gleichzeitig auf den Zähler zugreifen kann, wodurch Datenrennen verhindert werden.

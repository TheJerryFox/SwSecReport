\chapter{Besitz und Ausleihe}

In Rust sind Besitz und Ausleihe grundlegende Konzepte, die zur Gewährleistung der Speicher- und Datensicherheit beitragen. 
Das Besitzmodell sorgt dafür, dass es stets einen eindeutigen Besitzer eines Datenobjekts gibt, während das Ausleihmodell ermöglicht, dass andere Teile des Codes temporär auf diese Daten zugreifen können, ohne deren Besitzer zu ändern. 
Dies verhindert Datenrennen (\textit{\glspl{data-race}}) und Speicherfehler.

\section{Copy-Typen}
Copy-Typen sind einfache Datentypen, die eine bitweise Kopie beim Zuweisen erstellen. Primitive Typen wie \texttt{i32} sind Beispiele dafür.

\begin{lstlisting}[language=Rust, caption=Copy-Typen]
pub fn copy_type() 
{
    let i1 = 32;
    let i2 = i1;
    
    println!("{}, {}", i1, i2);
}
\end{lstlisting}
\noindent
Bei der Besitzübertragung wird der Besitz eines Datenobjekts von einer Variablen auf eine andere übertragen, was bedeutet, dass die ursprüngliche Variable nicht mehr auf das Objekt zugreifen kann.
Dies ist der Fall bei komplexen Typen wie \texttt{String}.

\begin{lstlisting}[language=Rust, caption=Unveränderliche Ausleihe]
pub fn transfer_ownership() {
    let s1 = String::from("Hello");
    // Ownership of the string is transferred from s1 to s2
    let s2 = s1;  

    // This line causes a compile-time error because 
    // s1 no longer owns the string.
    println!("{}", s1); 
    // This works perfectly, s2 now owns the data.
    println!("{}", s2); 
}
\end{lstlisting}
\cleardoublepage
\section{Ausleihe}
Ausleihe ermöglicht es, dass eine Variable auf die Daten einer anderen Variable zugreift, ohne deren Besitzer zu ändern. Dies kann entweder als unveränderliche oder veränderliche Referenz erfolgen.

\begin{lstlisting}[language=Rust, caption=Unveränderliche Ausleihe]
pub fn borrowing() {
    let s1 = String::from("Hello");
    // s2 is a reference to s1, s1 is borrowed
    let s2 = &s1;  

    // s1 is still valid and hasn't been moved.
    println!("{}", s1); 
    // s2 is a valid reference to s1.
    println!("{}", s2); 
}
\end{lstlisting}
\noindent
Veränderliche Referenzen ermöglichen das Ändern der Daten, auf die sie zeigen. Allerdings kann zu einem Zeitpunkt nur eine veränderliche Referenz existieren.

\begin{lstlisting}[language=Rust, caption=Veränderliche Referenz]
pub fn mut_reference() {
    let mut s1 = String::from("Hello");
    // s2 is a mutable reference to s1
    let mut s2 = &mut s1;  

    // only 1 mutable reference allowed
    // will panic
    let mut s3 = &mut s1;

    // Modifying s1 through its mutable reference s2
    s2.push_str(", world!"); 
    // This works and prints "Hello, world!"
    println!("{}", s2); 
}
\end{lstlisting}
\noindent
Im Gegensatz zu Rust erlauben viele andere Programmiersprachen wie C und C++ eine flexiblere, aber auch unsicherere Speicherverwaltung. 
In diesen Sprachen kann leicht unbeabsichtigter Code entstehen, der zu Speicherlecks oder Datenrennen führt, da hier Speicherplatz manuell allokiert und dessen Freigabe manuell verwaltet werden muss. Rusts strikte Regeln für Besitz und Ausleihe verhindern solche Probleme, indem sie sicherstellen, dass immer geregelt ist, wer für den Speicher eines Datenobjekts verantwortlich ist und wie darauf zugegriffen werden kann.
